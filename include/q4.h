#ifndef Q4_H
#define Q4_H
#include<numeric>

namespace q4
{
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    struct Vector2D
    {
        double x{};
        double y{}; 
    };
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    struct Sensor
    {
        Vector2D pos;
        double accuracy;    
    };
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    static double mean_x(double mean, Sensor& s)
    {
        return mean + s.pos.x * s.accuracy;
    }
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    static double mean_y(double mean, Sensor& s)
    {
        return mean + s.pos.y * s.accuracy;
    }
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    static double acc_sum(double sum, Sensor& s)
    {
        return sum + s.accuracy;   
    }
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    static Vector2D kalman_filter(std::vector<Sensor> sensors)
    {
        double accuracy_sum = std::accumulate(sensors.begin(), sensors.end(), 0.0 , acc_sum);
        double x_pos = std::accumulate(sensors.begin(), sensors.end(), 0.0, mean_x) / accuracy_sum;
        double y_pos = std::accumulate(sensors.begin(), sensors.end(), 0.0, mean_y) / accuracy_sum;

        Vector2D Position{};
        Position.x = x_pos;
        Position.y = y_pos;
        return Position;
    }
}

#endif //Q4_H